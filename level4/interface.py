from abc import ABC, abstractmethod


class ContactsManagerInterface(ABC):

    @abstractmethod
    def set_record(self, id: int, name: str, phone_number: str) -> bool:
        """
        Данная команда должна добавить в базу данных нового
        пользователя с указанными ID, именем, номером телефона.
        Если пользователь с таким ID уже существует,
        добавление невозможно – в таком случае, команда
        возвращает False. Если пользователь с таким ID
        был успешно добавлен – команда возвращает True.
        """
        pass

    @abstractmethod
    def delete_record(self, id: int) -> bool:
        """
        Данная команда удаляет пользователя с указанным ID
        из базы данных. Если удаление совершено успешно,
        команда возвращает True. Если пользователя с указанным
        ID не существует – команда возвращает False.
        """
        pass

    @abstractmethod
    def call(self, id: int) -> str:
        """
        Данная команда "совершает звонок" пользователю с
        указанным ID. Для этого команда должна вернуть строку
        "CALLING <NAME> WITH <PHONE NUMBER>. Если такого пользователя
        нет, команда возвращает строку "NO SUCH USER".
        """
        pass

    @abstractmethod
    def most_popular(self, n: int) -> list[str]:
        """
        Данная команда должна вернуть список N пользователей,
        которым звонят чаще всего. Если всего пользователей
        меньше, чем N – верните всех пользователей.
        Пользователи в списке должны быть отсортированы
        по количеству звонков в убывающем порядке.
        В случае ничьи – по алфавиту в возрастающем порядке.
        Команда возвращает список строк в данном формате:
        [<Name>(<Calls>), <Name2>(<Calls2>), ..., <NameN>(<CallsN>)]
        """
        pass

    @abstractmethod
    def call_with_ts(self, id: int, ts: int) -> str:
        """
        Данная команда работает так же, как и call, но сопровождает
        информацию о звонке таймстампом (целым числом, обозначающим время звонка).
        Гарантируется, что ts > 0 и ts в последовательных вызовах call_with_ts всегда
        возрастают. Команда возвращает строку "CALLING <NAME> WITH <PHONE NUMBER> AT <ts>".
        Если такого пользователя нет, команда возвращает строку "NO SUCH USER".
        """
        pass

    @abstractmethod
    def most_popular_in_range(self, n: int, ts_start: int, ts_end: int) -> list[str]:
        """
        Данная команда работает так же, как и most_popular, но работает только с теми звонками,
        которые были между ts_start и ts_end. Звонок, совершенный во время ts,
        считается попавшим в промежуток [ts_start, ts_end], если
        ts_start <= ts <= ts_end.
        """
        pass

    @abstractmethod
    def calls_history(self, id: int) -> list[str]:
        """
        Данная команда возвращает список звонков, совершенных пользователю
        с указанным ID. Каждый звонок должен быть представлен в виде одного
        единственного числа – своего ts. Звонки, совершенные без указания ts
        (с помощью операции call), должны быть представлены нулем. Звонки с нулем
        нет смысла выводить отдельно, поэтому их следует представить в виде "0(n)",
        где n – количество таких звонков

        Например, если пользователю с ID=1 звонили всего 5 раз таким образом:
        call(1)
        call_with_ts(1, 13)
        call_with_ts(1, 14)
        call(1)
        call_with_ts(1, 152)

        То вывод команды calls_history(1) будет таким:
        ["0(2)", "13", "14", "152"]
        """
        pass

    @abstractmethod
    def calls_history_grouped(self, id: int, window: int) -> list[str]:
        """
        Работает так же, как и calls_history, но группирует звонки, находящиеся
        в диапазоне window друг от друга. Парсинг звонков должен начинаться от первого
        (по времени) и до последнего по такому принципу:
        1. i-ый звонок назначается началом группы
        2. Если ts_(i+1) - ts(i) < window, то i+1ый звонок входит в данную группу
        Другими словами, если следующий звонок по времени произошел не позже, чем
        через window от начального в группе, то он тоже входит в эту группу
        3. Аналогично для i+2, i+3, ... звонков. Как только встречаем звонок, который не
        входит в группу, то есть ts_(i+j) - ts(i) >= window, группа считается завершенной, а
        i+jый звонок назначается началом новой группы

        Для каждой группы, возвращается время первого звонка в группе и в скобках количество звонков
        в группе

        Например:
        call(1)
        call(1)
        call_with_ts(1, 10)
        call_with_ts(1, 12)
        call_with_ts(1, 18)
        call_with_ts(1, 22)
        call_with_ts(1, 23)
        call_with_ts(1, 25)

        Тогда вывод команды calls_history_grouped(1, 3):
        ["0(2)", "10(2)", "18(1)", "22(3)"]

        Пояснение:
        "0(2)" отвечает за вызовы обычной call
        Первый звонок через call_with_ts был в 10. Он будет началом первой группы.
        Следующий звонок был в 12. Так как 12 - 10 = 2, что меньше window=3, этот
        звонок входит в первую группу
        Следующий звонок был в 18. Так как 18 - 10 = 8, а 8 > 3, этот
        звонок не входит в первую группу и является началом второй группы

        Таким образом, первая группа начинается в 10 и имеет в себе два звонка,
        поэтому представялется как "10(2)"

        Аналогично, вторая группа это "18(1)", а третья – "22(3)"
        """
        pass


